trigger:
- '*'

variables:
- group : Build
- name  : local.projectName
  value : 'PingDong.Core'
- name  : local.artifact
  value : 'packages'
  
stages:
- stage: Prepare
  displayName: Preparing
  jobs:
  - job: Preparing
    displayName: Preparing
    pool:
      vmImage: $(build.pool)
    workspace:
      clean: all
    steps:
    - checkout: none

    - task: UseDotNet@2
      displayName: Use .NET Core SDK $(build.dotnet.sdk.version)
      inputs:
        packageType: sdk
        version: $(build.dotnet.sdk.version)
        installationPath: $(Agent.ToolsDirectory)/dotnet

- stage: Test
  displayName: Testing
  dependsOn: Prepare
  condition: succeeded()
  jobs:
  - job: Static_Testing
    displayName: Static Testing
    pool:
      vmImage: $(build.pool)
    workspace:
      clean: all
    variables:
    - group: Build.Static_Test
    steps: 
    # TODO: SonarQube
    - task: SonarQubePrepare@4
      displayName: SonarQube
      enabled: false
      inputs:
        SonarQube: SonarQube
        scannerMode: MSBuild
        projectKey: $(local.projectName)
        projectName: $(local.projectName)
        extraProperties: |
          sonar.login=$(static_test.sonarqube:username)
          sonar.password=$(static_test.sonarqube:password)
          sonar.cs.opencover.reportsPaths="$(Build.SourcesDirectory)/TestResults/Coverage.opencover.xml"
    
    - task: SonarQubeAnalyze@4
      enabled: false

    # TODO: Improve WhiteSource Bolt
    - task: WhiteSource Bolt@20
      displayName: 'Run WhiteSource Bolt'
      enabled: false

  - job: Unit_Testing
    displayName: Unit_Testing
    pool:
      vmImage: $(build.pool)
    workspace:
      clean: all
    variables:
      - group : Build.Unit_Test
      - name  : local.codecoveragehistory.directory
        value : '$(Build.ArtifactStagingDirectory)/history'
      - name  : local.codecoveragehistory.directory
        value : ${{ lower( variables['local.projectName']) }}.$(Build.SourceBranchName)
      - name  : 'disable.coverage.autogenerate'
        value : 'true'
    steps:
    - task: UniversalPackages@0
      displayName: Get Code Coverage History
      continueOnError: true
      inputs:
        command: download
        downloadDirectory: $(local.codecoveragehistory.directory)
        feedsToUse: internal
        vstsFeed: $(unit_test.coverage.history.feed)
        vstsFeedPackage: $(local.codecoveragehistory.directory)
        vstsPackageVersion: '0.*'

    - task: DotNetCoreCLI@2
      displayName: Run Unit Tests
      inputs:
        command: test
        arguments: '--configuration $(build.configuration.release) /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura'
        publishTestResults: true
        projects: '**/*[Tt]ests/*.csproj'

    - task: Palmmedia.reportgenerator.reportgenerator-build-release-task.reportgenerator@4
      displayName: Generating Report
      inputs:
        reports: '$(Build.SourcesDirectory)/**/coverage.cobertura.xml'
        targetdir: $(Build.SourcesDirectory)/Coverage
        reporttypes: HtmlInline_AzurePipelines;Cobertura;Badges
        historydir: $(local.codecoveragehistory.directory)

    - task: UniversalPackages@0
      displayName: Publish Code Coverage History
      inputs:
        command: publish
        publishDirectory: $(local.codecoveragehistory.directory)
        feedsToUsePublish: internal
        vstsFeedPublish: $(unit_test.coverage.history.feed)
        vstsFeedPackagePublish: $(local.codecoveragehistory.directory)
        versionOption: patch
        packagePublishDescription: Code Coverage History for repository $(Build.Repository.Name) on branch $(Build.SourceBranchName)
        verbosity: Information

    - task: PublishCodeCoverageResults@1
      displayName: Publish Code Coverage Report
      inputs:
        codeCoverageTool: Cobertura
        summaryFileLocation: $(Build.SourcesDirectory)/Coverage/Cobertura.xml
        reportDirectory: $(Build.SourcesDirectory)/Coverage
  
- stage: Package
  displayName: Packaging
  dependsOn: Test
  condition: succeeded()
  jobs:
  - job: Package
    displayName: Packaging
    pool:
      vmImage: $(build.pool)
    workspace:
      clean: all
    variables:
    - group: Build.NuGet
    steps:      
    - task: DotNetCoreCLI@2
      displayName: Create Pre-release Package
      condition: ne(variables['Build.SourceBranch'], 'refs/heads/master')
      inputs:
        command: pack
        buildProperties: $(nuget.prerelease.suffix)
        packDirectory: '$(Build.ArtifactStagingDirectory)/packages'
        arguments: '--configuration $(build.configuration.release)'

    - task: DotNetCoreCLI@2
      displayName: Create Release Package
      condition: eq(variables['Build.SourceBranch'], 'refs/heads/master')
      inputs:
        command: pack
        packDirectory: '$(Build.ArtifactStagingDirectory)/packages'
        arguments: '--configuration $(build.configuration.release)'
  
    - publish: $(Build.ArtifactStagingDirectory)/packages
      displayName: Publishing
      artifact: $(local.artifact)

# Prerelease
- stage: Publish_Prerelease
  displayName: Publish Prerelease
  dependsOn: Package
  condition: |
    and
    (
      succeeded(),
      ne(variables['Build.SourceBranch'], 'refs/heads/master')
    )
  jobs:
  - job: Publishing   
    displayName: Publishing     
    pool:
      vmImage: $(build.pool)
    workspace:
      clean: all
    variables:
    - group: Build.NuGet
    steps:
      - checkout: none

      - download: current
        artifact: $(local.artifact)

      - task: NuGetCommand@2
        displayName: Push NuGet Package
        inputs:
          command: push
          packagesToPush: '$(Pipeline.Workspace)/packages/*.nupkg'
          nuGetFeedType: internal
          publishVstsFeed: $(nuget.artifact.feed.prerelease)

# Release
- stage: Publish_To_AzureDevops
  displayName: Publish to Azure DevOps Feed
  dependsOn: Package
  condition: | 
    and
    (
      succeeded(),
      eq(variables['Build.SourceBranch'], 'refs/heads/master')
    )
  jobs:
  - job: Publishing 
    displayName: Publishing      
    pool:
      vmImage: $(build.pool)
    workspace:
      clean: all
    variables:
    - group: Build.NuGet
    steps:
      - checkout: none

      - download: current
        artifact: $(local.artifact)

      - task: NuGetCommand@2
        displayName: Pushing
        inputs:
          command: push
          packagesToPush: '$(Pipeline.Workspace)/packages/*.nupkg'
          nuGetFeedType: internal
          publishVstsFeed: $(nuget.artifact.feed.production)
          allowPackageConflicts: true
      
- stage: Publish_To_NuGet
  displayName: Publish to NuGet
  dependsOn: Package
  condition: |
    and
    (
      succeeded(),
      eq(variables['Build.SourceBranch'], 'refs/heads/master')
    )
  jobs:
  - deployment:
    displayName: Publishing
    pool:
      vmImage: $(build.pool)
    workspace:
      clean: all
    variables:
    - group: Build.NuGet
    environment: NuGet-Repo
    strategy:
      runOnce:
        deploy:
          steps:
            - checkout: none

            - download: current
              artifact: $(local.artifact)

            - task: NuGetCommand@2
              displayName: Pushing
              inputs:
                command: push
                packagesToPush: '$(Pipeline.Workspace)/packages/*.nupkg'
                nuGetFeedType: external
                publishFeedCredentials: $[ variables['nuget.connection'] ]
